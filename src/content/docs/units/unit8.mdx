---
title: Unidad 8
unitId: unit8
---

import { Aside } from '@astrojs/starlight/components';

## Introducci√≥n üìú

En esta √∫ltima unidad, exploraremos el mundo de la concurrencia utilizando 
**hilos** (threads). Aprender√°s c√≥mo un solo programa puede ejecutar m√∫ltiples 
secuencias de instrucciones aparentemente al mismo tiempo. Descubrir√°s los dos grandes 
beneficios: mantener tu aplicaci√≥n **responsiva** incluso cuando realiza tareas largas 
y acelerar c√°lculos intensivos mediante el **paralelismo**. Sin embargo, tambi√©n enfrentaremos 
el principal desaf√≠o: gestionar de forma segura los datos compartidos entre hilos para 
evitar errores. Utilizaremos proyectos ejemplo y analizaremos ejemplos 
funcionales para entender estos conceptos de forma pr√°ctica.

## Set: ¬øQu√© aprender√°s en esta unidad? üí°

* **Diferenciar conceptos:** entender√°s la diferencia b√°sica entre proceso e hilo.  
* **Identificar beneficios:** reconocer√°s cu√°ndo usar hilos para mejorar la responsividad o el rendimiento (paralelismo).  
* **Analizar c√≥digo concurrente:** examinar√°s ejemplos que usan hilos para realizar tareas en segundo plano o en paralelo.  
* **Comprender la sincronizaci√≥n b√°sica:** entender√°s por qu√© es necesario proteger datos compartidos y c√≥mo usar mecanismos simples como `lock`/`unlock` (mutex).  
* **Medir y comparar rendimiento:** evaluar√°s el impacto del paralelismo en tareas computacionales.  
* **Aplicar conceptos:** modificar√°s un ejemplo existente para implementar una tarea paralela interactiva.  

### Actividad 01

#### Orientaci√≥n y Conceptos

:::note[üéØ Enunciado]
En esta actividad introductoria, vamos a explorar de manera pr√°ctica los conceptos que aprender√°s en esta unidad. 
:::

En esta unidad vamos a utilizar algunos servicios del sistema operativo que te permitir√°n acceder a m√∫ltiples 
recursos de procesamiento del hardware de tu computador: **los cores**. Para ello utilizar√°s de nuevo openFrameworks.

**¬øQu√© es un sistema operativo?**

En t√©rminos generales, un sistema operativo es un SOFTWARE que administra RECURSOS de hardware y software del computador 
y provee servicios mediante los cuales los programas de usuario pueden hacer uso de esos recursos.

El servicio que vamos a explorar en esta actividad es el de hilos o threads. Un hilo es una unidad de ejecuci√≥n dentro de 
un proceso. Un proceso puede contener m√∫ltiples hilos, cada uno de los cuales puede ejecutar su propio c√≥digo de manera 
concurrente. Los hilos comparten el mismo espacio de memoria y recursos del proceso, lo que les permite comunicarse entre s√≠ de manera eficiente.

**¬øQu√© es esto de un proceso?** No es m√°s que un programa en ejecuci√≥n. Entonces en t√©rminos simples, los hilos permiten que 
un proceso (programa en ejecuci√≥n) pueda ejecutar m√∫ltiples tareas al mismo tiempo.

**De nuevo ¬øQu√© es un hilo?** 

Hasta ahora todos los programas que has realizado tienen un **SOLO flujo de instrucciones**. ¬øY si quieres tener en el 
mismo programa VARIOS flujos de instrucciones independientes? Lo puedes hacer con los hilos. Los hilos permitir√°n que un 
programa pueda **HACER VARIAS COSAS AL MISMO TIEMPO**, cada cosa con un hilo independiente. Ten presente que los 
hilos compartir√°n recursos del proceso, entre ellos estar√° el HEAP; sin embargo, cada hilo tendr√° su propio 
STACK (que belleza, ya podemos relacionar el stack y el heap con los hilos).

**Y en la pr√°ctica ¬øC√≥mo ser√≠a la cosa?**

Crea un proyecto en openFrameworks y modifica el archivo `ofApp.h` para que contenga lo siguiente:

```cpp
#pragma once
#include "ofMain.h"

class ofApp : public ofBaseApp {
public:
    float x = 0;
    float speed = 3;
    float circleSize = 50;

    void setup();
    void draw();
    void mousePressed(int x, int y, int button);
    void heavyComputation();
};

```

Ahora modifica el archivo `ofApp.cpp` para que contenga lo siguiente:

```cpp
#include "ofApp.h"

void ofApp::setup() {
    ofSetFrameRate(60);
    ofSetWindowShape(400, 400);
}

void ofApp::draw() {
    ofBackground(220);
    ofSetColor(0);
    ofDrawCircle(x, ofGetHeight() / 2, circleSize);
    x = fmod(x + speed, ofGetWidth());
}

void ofApp::mousePressed(int x, int y, int button) {
    heavyComputation();
}

void ofApp::heavyComputation() {
    double result = 0;
    for (int j = 0; j < 1000000000; ++j) {
        result += sqrt(j);
    }
    circleSize = ofRandom(20, 70);
    ofLog() << "Circle size: " << circleSize;
}
```

:::note[üßêüß™‚úçÔ∏è Reporta en tu bit√°cora]
Ejecuta el programa y haz clic en la ventana. Observa lo que sucede. ¬øQu√© es lo que ves? ¬øQu√© es lo que esperabas ver? 
¬øPor qu√© crees que sucede esto?
:::

El problema que acabas de observar es que el programa se congela cuando haces clic en la ventana. Esto sucede porque 
la funci√≥n `heavyComputation()` est√° bloqueando el hilo principal de la aplicaci√≥n, lo que impide que la interfaz gr√°fica se actualice.
Esto es un problema com√∫n en aplicaciones que requieren realizar c√°lculos intensivos o tareas de larga duraci√≥n. La 
soluci√≥n a este problema es mover la tarea pesada a un hilo separado, lo que permitir√° que la interfaz gr√°fica siga siendo responsiva mientras se realiza el c√°lculo.

Ahora vamos a crear un hilo para la funci√≥n `heavyComputation()`. Para ello, primero debes incluir la biblioteca de hilos de openFrameworks en tu archivo `ofApp.h`:

```cpp
#include "ofMain.h"
#include "ofThread.h"
```
Luego, debes crear una clase que herede de `ofThread` y que contenga la funci√≥n `heavyComputation()`. Modifica el archivo `ofApp.h` para que contenga lo siguiente:

```cpp
#pragma once
#include "ofMain.h"
#include "ofThread.h"

class ofApp : public ofBaseApp, public ofThread {
public:
    float x = 0;
    float speed = 3;
    float circleSize = 50;

    void setup();
    void draw();
    void mousePressed(int x, int y, int button);
    void heavyComputation();
    void startHeavyComputation();
    void threadedFunction() override;
    void exit();
};
```

Modifica el archivo `ofApp.cpp` para que contenga lo siguiente:

```cpp
#include "ofApp.h"

void ofApp::setup() {
    ofSetFrameRate(60);
    ofSetWindowShape(400, 400);
}

void ofApp::draw() {

    ofBackground(220);
    ofSetColor(0);
    lock();
    ofDrawCircle(x, ofGetHeight() / 2, circleSize);
    unlock();
    x = fmod(x + speed, ofGetWidth());
}

void ofApp::mousePressed(int x, int y, int button) {
    if (!isThreadRunning()) {
        std::cout << "Starting heavy computation in a thread" << std::endl;
        startThread();
    }
    else {
        std::cout << "Thread is already running" << std::endl;
    }
}

void ofApp::threadedFunction() {
    heavyComputation();
    std::cout << "Thread ends" << std::endl;
}

void ofApp::heavyComputation() {
    double result = 0;
    for (int j = 0; j < 1000000000; ++j) {
        result += sqrt(j);
    }
    lock();
    ofSeedRandom();
    circleSize = ofRandom(20, 70);
    unlock();
	std::cout << "Circle size: " << circleSize << std::endl;
}

void ofApp::exit() {
    if (isThreadRunning()) {
        stopThread();
        waitForThread();
    }
}

```
:::note[üßêüß™‚úçÔ∏è Reporta en tu bit√°cora]
Ejecuta el programa y haz clic en la ventana. Observa lo que sucede. ¬øQu√© es lo que ves? ¬øQu√© es lo que esperabas 
ver? ¬øPor qu√© crees que sucede esto?

Observa que el programa ahora no se congela, pero el c√≠rculo no cambia de tama√±o inmediatamente. ¬øPor qu√© crees 
que sucede esto? ¬øQu√© es lo que est√° pasando?
:::

Vamos a repasar de nuevo algunos conceptos importantes:

**Repaso de conceptos**
*   **Proceso:** una instancia de un programa en ejecuci√≥n (tiene su propia memoria: stack, heap, etc.).
*   **Hilo (Thread):** un flujo de instrucciones *dentro* de un proceso. Un proceso puede tener m√∫ltiples hilos. En el √∫ltimo 
programa, ¬øPuedes identificar los hilos que se est√°n ejecutando? ¬øCu√°ntos hilos hay en total? La cantidad de hilos cambia 
cuando ¬øHaces clic en la ventana? ¬øTermina el heavyComputation()?
*   **Memoria Compartida:** los hilos dentro del mismo proceso comparten la mayor parte de la memoria (como el heap y las variables globales). ¬°Esto es potente pero peligroso! Cada hilo tiene su *propio* stack para variables locales y llamadas a funciones.
*   **Concurrencia:** la idea de que m√∫ltiples tareas parecen progresar al mismo tiempo (pueden estar intercal√°ndose en un solo n√∫cleo o corriendo en paralelo en m√∫ltiples n√∫cleos).
*   **Paralelismo:** la ejecuci√≥n *simult√°nea* real de m√∫ltiples tareas (requiere hardware con m√∫ltiples n√∫cleos).

:::note[üßêüß™‚úçÔ∏è Reporta en tu bit√°cora]
En tus propias palabras, explica la diferencia entre concurrencia y paralelismo. ¬øPor qu√© es importante entender esta diferencia al trabajar con hilos?
:::


## Seek: Investigaci√≥n üîé

### Actividad 02

#### Debes sincronizar los hilos

:::note[üéØ Enunciado]
En la actividad anterior pudiste ver c√≥mo lograr que el hilo principal no se congele, pero esto tuvo un costo que en 
principio no es tan obvio. Cuando dos hilos comparten datos, es necesario sincronizarlos para evitar que se
produzcan condiciones de carrera. En este caso, el hilo principal y el hilo de heavyComputation() est√°n accediendo a la
variable circleSize. Si el hilo de heavyComputation() cambia el valor de circleSize mientras el hilo principal lo est√°
usando, puede provocar un comportamiento inesperado.
:::

**¬øQu√© es una condici√≥n de carrera?**
Una condici√≥n de carrera es un error que ocurre cuando dos o m√°s hilos acceden a un recurso compartido y al menos uno de 
ellos lo modifica. Esto puede provocar resultados inesperados, ya que el resultado final depende del orden en que se ejecutan los hilos.
Por ejemplo, si un hilo est√° leyendo el valor de circleSize mientras otro hilo lo est√° modificando, el hilo que lee puede 
obtener un valor incorrecto. Esto puede provocar que el c√≠rculo se dibuje en una posici√≥n incorrecta o que se produzcan otros errores en el programa.

Mira, este tipo de errores son dif√≠ciles de detectar y depurar, ya que pueden ocurrir en cualquier momento y no siempre se producen. 
Por eso es importante sincronizar los hilos para evitar condiciones de carrera.
Para sincronizar los hilos, puedes usar un mutex (mutual exclusion). Un mutex es un objeto que se utiliza para proteger el acceso a 
un recurso compartido. Cuando un hilo quiere acceder al recurso, debe bloquear el mutex. Si otro hilo intenta acceder al mismo 
recurso mientras el mutex est√° bloqueado, debe esperar hasta que el mutex se desbloquee.
Esto garantiza que solo un hilo pueda acceder al recurso a la vez, evitando as√≠ condiciones de carrera.

:::note[üßêüß™‚úçÔ∏è Reporta en tu bit√°cora]
Analiza de nuevo el c√≥digo de la actividad anterior. ¬øEn qu√© partes del c√≥digo se est√° protegiendo el acceso a la variable circleSize?

Seg√∫n lo que te he venido comentando, los hilos te permiten ejecutar tareas en paralelo; sin embargo, piensa qu√© ocurre con 
el paralelismo cuando se sincroniza el acceso a un recurso compartido. ¬øQu√© ocurre con el rendimiento del programa? ¬øEs posible que el rendimiento se vea afectado por el uso de mutex? ¬øPor qu√©?
:::

Ahora quiero mostrarte un ejemplo m√°s dram√°tico de una condici√≥n de carrera. Para ello te pedir√© que modifiques el c√≥digo 
de ofApp.h para que contenga lo siguiente:
```cpp
#pragma once
#include "ofMain.h"
#include "ofThread.h"

// Par√°metros fijos ‚Äï modifica si quieres
const int  NUM_THREADS = 4;        
const long NUM_STEPS = 1000000;  

//--------------------------------------------------------------
class CounterThread : public ofThread {
public:
    CounterThread(long* sharedCounter,
        ofThread* sharedLocker,
        bool* lockFlag)
        : counter(sharedCounter)
        , locker(sharedLocker)
        , useLock(lockFlag)
    {
    }

    void threadedFunction() override {
        for (long i = 0; i < NUM_STEPS; ++i) {
            if (*useLock) {                 
                locker->lock();          
                ++(*counter);
                locker->unlock();
            }
            else {                        
                ++(*counter);             
            }
        }
    }
private:
    long* counter;   
    ofThread* locker;    
    bool* useLock;   
};

//--------------------------------------------------------------
class ofApp : public ofBaseApp {
public:
    void setup();
    void draw();
    void exit();
    void keyPressed(int);

private:
    // L√≥gica auxiliar
    void startTest();
    void stopWorkers();

    long counter = 0;           
    bool useLock = true;        

    CounterThread* workers[NUM_THREADS]; 
    ofThread       locker;
};
```

Y modifiques el c√≥digo de ofApp.cpp para que contenga lo siguiente:

```cpp
#include "ofApp.h"

//--------------------------------------------------------------
void ofApp::setup() {
    ofSetFrameRate(60);
    startTest();
}

//--------------------------------------------------------------
void ofApp::startTest() {
    counter = 0;

    ofSetWindowTitle(
        std::string(useLock ? "SAFE" : "UNSAFE") +
        "  |  's' toggle lock  |  'r' restart");

    for (int i = 0; i < NUM_THREADS; ++i) {
        workers[i] = new CounterThread(&counter, &locker, &useLock);
        workers[i]->startThread();
    }
}

//--------------------------------------------------------------
void ofApp::stopWorkers() {
    for (int i = 0; i < NUM_THREADS; ++i) {
        if (workers[i]) {
            workers[i]->waitForThread(true);
            delete workers[i];
            workers[i] = nullptr;
        }
    }
}

//--------------------------------------------------------------
void ofApp::draw() {
    ofBackground(30);
    ofSetColor(255);

    long expected = NUM_THREADS * NUM_STEPS;

    ofDrawBitmapStringHighlight(
        std::string(useLock ? "Modo SEGURO - con lock()" :
            "Modo INSEGURO - sin lock()"),
        20, 40);
    ofDrawBitmapStringHighlight(
        "Contador:  " + ofToString(counter), 20, 70);
    ofDrawBitmapStringHighlight(
        "Esperado:  " + ofToString(expected), 20, 100);
    ofDrawBitmapStringHighlight(
        "Pulsa  's'  para alternar  |  'r'  para reiniciar",
        20, 130);
}

//--------------------------------------------------------------
void ofApp::keyPressed(int key) {
    if (key == 'r' || key == 'R') {     // reiniciar prueba
        stopWorkers();
        startTest();
    }
    if (key == 's' || key == 'S') {     // alternar lock / unlock
        useLock = !useLock;
        stopWorkers();
        startTest();
    }
}

//--------------------------------------------------------------
void ofApp::exit() {
    stopWorkers();                    // limpieza ordenada
}
```

:::note[üßêüß™‚úçÔ∏è Reporta en tu bit√°cora]
Ejecuta el c√≥digo y observa el resultado. ¬øQu√© ocurre si cambias el valor de la variable 
useLock? ¬øPor qu√© crees que ocurre esto?
:::

**¬øPor qu√© ocurre la condici√≥n de carrera en este caso?**

La condici√≥n de carrera ocurre porque varios hilos est√°n accediendo y modificando la misma variable `counter` al 
mismo tiempo. Cuando `useLock` es verdadero, el acceso a `counter` est√° protegido por un mutex, lo que evita que 
varios hilos lo modifiquen al mismo tiempo. Sin embargo, cuando `useLock` es falso, los hilos pueden modificar 
`counter` simult√°neamente, lo que puede provocar resultados inesperados.

**Pero ¬øQu√© puede estar pasando para que esto ocurra?**

Cuando varios hilos intentan incrementar `counter` al mismo tiempo, pueden leer el mismo valor inicial de `counter`, 
incrementarlo y luego escribir el nuevo valor. Esto significa que dos hilos pueden leer el mismo valor, incrementarlo 
y escribirlo de nuevo, lo que provoca que se pierda una actualizaci√≥n.
Esto se debe a que la operaci√≥n de incremento no es at√≥mica, lo que significa que no se puede garantizar que un 
hilo complete la operaci√≥n antes de que otro hilo comience. Por lo tanto, si dos hilos intentan incrementar `counter` 
al mismo tiempo, pueden interferir entre s√≠ y provocar resultados inesperados.

**¬øLo puedes ver?** Te doy un poco m√°s de ideas. Conc√©ntrate en esta l√≠nea:

```cpp
++(*counter);
```

¬øRecuerdas la unidad 1 y 2? Piensa en t√©rminos de acceso a la memoria y manejo de los registros del procesador (en la unidad 1 
nuestros registros eran A y D, ¬øRecuerdas?). ¬øC√≥mo crees que el procesador realice la l√≠nea de c√≥digo anterior?

Para incrementar el valor de `counter`, el procesador debe realizar varias operaciones:
1. Leer el valor actual de `counter` desde la memoria. Ese valor se lee a un registro del procesador.
2. Incrementar el valor le√≠do. El c√°lculo se realiza en el registro del procesador.
3. Escribir el nuevo valor de `counter` de nuevo en la memoria. El valor que est√° en el registro se escribe de nuevo en la memoria.

Esto implica que el procesador debe acceder a la memoria varias veces (¬øCu√°ntas?) para realizar la operaci√≥n de incremento. Si varios hilos intentan realizar esta operaci√≥n al mismo tiempo, pueden interferir entre s√≠ y provocar resultados inesperados.


:::note[üßêüß™‚úçÔ∏è Reporta en tu bit√°cora]
Explica en tus propias palabras ¬øC√≥mo puede presentarse la condici√≥n de carrera en este caso? ¬øQu√© es lo que est√° pasando? 
Te pido que propongas un ejemplo.
:::

### Actividad 03

#### Hilos para el paralelismo

:::note[üéØ Enunciado]
Otro uso clave de los hilos es acelerar tareas que requieren mucho c√°lculo, siempre que estas tareas puedan dividirse en partes independientes. No olvides la actividad anterior por favor. Si hay datos compartidos entre los hilos, debes proteger el acceso a esos datos. En esta actividad vas a observar el rendimiento de un algoritmo para calcular un fractal de Mandelbrot. El algoritmo se puede paralelizar, ya que cada pixel del fractal se puede calcular de forma independiente. La idea ser√° entonces que compares el rendimiento de un algoritmo secuencial y uno paralelo.
:::

**Fractal de Mandelbrot**

El fractal de Mandelbrot es un conjunto de puntos en el plano complejo que se define mediante una funci√≥n iterativa. La funci√≥n se basa en la siguiente f√≥rmula:

$$
z_{n+1} = z_n^2 + c
$$

donde z es un n√∫mero complejo y c es una constante compleja. 

El conjunto de Mandelbrot se forma al iterar esta funci√≥n y observar si los puntos permanecen dentro de un cierto rango o "escapan" a infinito. 

El conjunto de Mandelbrot se representa visualmente asignando un color a cada punto en funci√≥n del n√∫mero de iteraciones que tarda en escapar a infinito. Los puntos que no escapan se consideran parte del conjunto y se les asigna un color espec√≠fico (generalmente negro). Los puntos que escapan se les asigna un color en funci√≥n de cu√°ntas iteraciones tardaron en escapar. Esto crea una imagen fractal con patrones complejos y hermosos.

El algoritmo para calcular el conjunto de Mandelbrot implica iterar sobre cada p√≠xel de la imagen y aplicar la funci√≥n iterativa. Para cada p√≠xel, se mapea a un punto en el plano complejo y se calcula cu√°ntas iteraciones tarda en escapar a infinito. El n√∫mero m√°ximo de iteraciones se puede ajustar para obtener m√°s o menos detalle en la imagen.

El algoritmo b√°sico para calcular el conjunto de Mandelbrot es el siguiente:

1. Inicializar una imagen en blanco.
2. Para cada p√≠xel de la imagen:
   1. Mapear las coordenadas del p√≠xel a un punto en el plano complejo.
   2. Inicializar z = 0 y c = punto complejo.
   3. Iterar la funci√≥n $$z = z^2 + c$$ hasta que $$|z| > 2$$ o se alcance el n√∫mero m√°ximo de iteraciones.
   4. Asignar un color al p√≠xel en funci√≥n del n√∫mero de iteraciones.
5. Mostrar la imagen resultante.

El algoritmo de Mandelbrot es un ejemplo cl√°sico de un problema que se puede paralelizar, ya que cada p√≠xel se puede calcular de forma independiente. Esto significa que puedes dividir el trabajo entre varios hilos y calcular el conjunto de Mandelbrot m√°s r√°pidamente.

El c√≥digo que te propongo a continuaci√≥n es un ejemplo de c√≥mo implementar el algoritmo de Mandelbrot en openFrameworks. El c√≥digo est√° dividido en dos versiones: una secuencial y otra paralela. La versi√≥n paralela utiliza hilos para acelerar el c√°lculo del conjunto de Mandelbrot.

**Versi√≥n secuencial**:

ofApp.h

```cpp
// ofApp.h
#pragma once

#include "ofMain.h"

class ofApp : public ofBaseApp {

public:
    void setup();
    void update();
    void draw();
    void keyPressed(int key);

    void startCalculation();
    int calculateMandelbrotPixel(int x, int y);
    ofColor mapIterationsToColor(int iterations);

    ofPixels pixels;      
    ofTexture texture;    

    int imgWidth;
    int imgHeight;
    int maxIterations;

    float startTime;
    float calculationTime;
    bool calculating;
    string statusMessage;
};
```

ofApp.cpp:


```cpp
// ofApp.cpp

#include "ofApp.h" 

void ofApp::setup() {
    ofSetWindowTitle("Mandelbrot Secuencial");
    ofSetFrameRate(60); 
    ofBackground(30);

    imgWidth = ofGetWidth(); 
    imgHeight = ofGetHeight();
    maxIterations = 100; 

    pixels.allocate(imgWidth, imgHeight, OF_PIXELS_RGB);
    texture.allocate(pixels);

    calculating = false;
    calculationTime = 0.0f;
    statusMessage = "Listo. \nPresiona ESPACIO para calcular.";
}

//--------------------------------------------------------------
void ofApp::startCalculation() {
    if (calculating) return; 

    calculating = true;
    statusMessage = "Calculando...";
    ofLogNotice() << statusMessage;
    startTime = ofGetElapsedTimef(); // Tiempo en segundos

    // --- C√°lculo Secuencial ---
    for (int y = 0; y < imgHeight; ++y) {
        for (int x = 0; x < imgWidth; ++x) {
            int iterations = calculateMandelbrotPixel(x, y);
            pixels.setColor(x, y, mapIterationsToColor(iterations));
        }
    }
    // --- Fin C√°lculo ---

    calculationTime = ofGetElapsedTimef() - startTime;
    calculating = false;
    statusMessage = "C√°lculo completado. \nPresiona ESPACIO para recalcular.";
    ofLogNotice() << statusMessage << " Tiempo: " << calculationTime << " s";

    // Actualizar la textura con los nuevos p√≠xeles
    texture.loadData(pixels);
}

//--------------------------------------------------------------
int ofApp::calculateMandelbrotPixel(int x, int y) {
    // Mapear coordenadas de p√≠xel a plano complejo
    // Rango t√≠pico: x de -2.0 a 1.0, y de -1.5 a 1.5
    float cx = ofMap(x, 0, imgWidth, -2.0, 1.0);
    float cy = ofMap(y, 0, imgHeight, -1.5, 1.5);

    float zx = 0.0;
    float zy = 0.0;
    int iterations = 0;

    while ( (zx * zx + zy * zy) < 4.0 && iterations < maxIterations) {
        float tempX = zx * zx - zy * zy + cx;
        zy = 2.0 * zx * zy + cy;
        zx = tempX;
        iterations++;
    }
    return iterations;
}

//--------------------------------------------------------------
ofColor ofApp::mapIterationsToColor(int iterations) {
    if (iterations == maxIterations) {
        return ofColor::black; // Dentro del conjunto
    }
    else {
        float hue = ofMap(iterations, 0, maxIterations, 0, 255);
        float brightness = ofMap(iterations, 0, maxIterations, 100, 255);
        float saturation = 200; // Constante para color
        return ofColor::fromHsb(hue, saturation, brightness); // Colorido
    }
}

//--------------------------------------------------------------
void ofApp::update() {
}

//--------------------------------------------------------------
void ofApp::draw() {
    ofSetColor(255); // Dibujar textura con color blanco
    texture.draw(0, 0, ofGetWidth(), ofGetHeight());

    // --- UI de M√©tricas ---
    stringstream ss;
    ss << "Version: Secuencial" << endl;
    ss << "Status: " << statusMessage << endl;
    if (!calculating && calculationTime > 0.0f) {
        ss << "Ultimo Tiempo: " << ofToString(calculationTime, 3) << " s" << endl;
    }
    ss << "Max Iteraciones: " << maxIterations << endl;
    ss << "Resolucion: " << imgWidth << "x" << imgHeight << endl;
    ss << "FPS: " << ofToString(ofGetFrameRate(), 0); // Ser√° bajo o 0 durante el c√°lculo

    ofSetColor(0, 180); // Fondo semi-transparente para el texto
    ofDrawRectangle(10, 10, 350, 120);
    ofSetColor(255); // Texto blanco
    ofDrawBitmapString(ss.str(), 20, 30);
}

//--------------------------------------------------------------
void ofApp::keyPressed(int key) {
    if (key == ' ') {
        maxIterations += 1;
        startCalculation();
        
    }
    if (key == 'n') {

        maxIterations = 0;
        startCalculation();
    }
}
```

**Versi√≥n paralela**:

ofApp.h

```cpp
// ofApp.h
#pragma once

#include "ofMain.h"
#include "ofThread.h" 

class MandelbrotThread : public ofThread {
public:
    MandelbrotThread(int startY, int endY, int width, int height, int maxIter, ofPixels& pixelsRef)
        : startRow(startY), endRow(endY), imgWidth(width), imgHeight(height),
        maxIterations(maxIter), pixels(pixelsRef) {
    } 

    void threadedFunction() override {
        for (int y = startRow; y < endRow && isThreadRunning(); ++y) {
            for (int x = 0; x < imgWidth; ++x) {
                int iterations = calculateMandelbrotPixel(x, y);
                pixels.setColor(x, y, mapIterationsToColor(iterations));
            }
        }
        
        ofLogVerbose("MandelbrotThread") << "Hilo para filas " << startRow << "-" << endRow << " terminado.";
    }

private:
    int startRow, endRow;
    int imgWidth, imgHeight;
    int maxIterations;
    ofPixels& pixels; 

    int calculateMandelbrotPixel(int x, int y) {
        float cx = ofMap(x, 0, imgWidth, -2.0, 1.0);
        float cy = ofMap(y, 0, imgHeight, -1.5, 1.5);
        float zx = 0.0, zy = 0.0;
        int iterations = 0;
        while (zx * zx + zy * zy < 4.0 && iterations < maxIterations) {
            float tempX = zx * zx - zy * zy + cx;
            zy = 2.0 * zx * zy + cy;
            zx = tempX;
            iterations++;
        }
        return iterations;
    }

    ofColor mapIterationsToColor(int iterations) {
        if (iterations == maxIterations) return ofColor::black;
        else {
            float hue = ofMap(iterations, 0, maxIterations, 0, 255);
            float brightness = ofMap(iterations, 0, maxIterations, 100, 255);
            float saturation = 200;
            return ofColor::fromHsb(hue, saturation, brightness);
        }
    }
};


class ofApp : public ofBaseApp {

public:
    void setup();
    void update();
    void draw();
    void exit(); 
    void keyPressed(int key);

    void startCalculation();

    ofPixels pixels;
    ofTexture texture;

    int imgWidth;
    int imgHeight;
    int maxIterations;
    int numThreads;

    vector<MandelbrotThread*> threads; 

    float startTime;
    float calculationTime;
    bool calculating;
    string statusMessage;
    int runningThreads;
};

```

ofApp.cpp

```cpp
// ofApp.cpp
#include "ofApp.h" 
#include <thread> 

//--------------------------------------------------------------
void ofApp::setup() {
    ofSetWindowTitle("Mandelbrot Paralelo (ofThread)");
    ofSetFrameRate(60);
    ofBackground(30);

    imgWidth = ofGetWidth();
    imgHeight = ofGetHeight();
    maxIterations = 100;

    numThreads = std::thread::hardware_concurrency();
    
    if (numThreads == 0) numThreads = 4; // Fallback si no se puede detectar
    ofLogNotice() << "Usando " << numThreads << " hilos.";

    pixels.allocate(imgWidth, imgHeight, OF_PIXELS_RGB);
    texture.allocate(pixels);

    calculating = false;
    calculationTime = 0.0f;
    runningThreads = 0;
    statusMessage = "Listo. \nPresiona ESPACIO para calcular.";

}

//--------------------------------------------------------------
void ofApp::startCalculation() {
    if (calculating) {
        ofLogWarning() << "Ya se est√° calculando, espera a que termine.";
        return;
    }
    calculating = true;
    runningThreads = 0; // Reseteamos contador antes de lanzar nuevos
    statusMessage = "Calculando con " + ofToString(numThreads) + " hilos...";

    ofLogNotice() << statusMessage;
    startTime = ofGetElapsedTimef();

    if (!threads.empty()) {
        ofLogVerbose() << "Limpiando hilos anteriores...";
        for (auto& thread : threads) {
            thread->waitForThread(true); 
            delete thread;
        }
        threads.clear();
        ofLogVerbose() << "Hilos anteriores limpiados.";
    }

    int rowsPerThread = imgHeight / numThreads;
    for (int i = 0; i < numThreads; ++i) {
        int startY = i * rowsPerThread;
        int endY = (i == numThreads - 1) ? imgHeight : (i + 1) * rowsPerThread; // Asegura que el √∫ltimo hilo llegue hasta el final

        MandelbrotThread* newThread = new MandelbrotThread(startY, endY, imgWidth, imgHeight, maxIterations, pixels);
        threads.push_back(newThread);
        runningThreads++;
        threads.back()->startThread(); // Inicia la ejecuci√≥n de threadedFunction
        ofLogVerbose() << "Lanzado hilo " << i << " para filas " << startY << "-" << endY;
    }
    ofLogNotice() << runningThreads << " hilos lanzados.";
}

//--------------------------------------------------------------
void ofApp::update() {
    bool allThreadsFinished = true;
    if (!threads.empty()) { // Solo comprobar si hay hilos
        for (const auto& thread : threads) {
            if (thread->isThreadRunning()) {
                allThreadsFinished = false;
                break; // Si uno sigue corriendo, no necesitamos comprobar los dem√°s
            }
        }
    }
    else {
        // Si no hay hilos en el vector, definitivamente no est√°n corriendo
        allThreadsFinished = true;
    }

    if (allThreadsFinished && calculating) {
        calculationTime = ofGetElapsedTimef() - startTime;
        calculating = false;
        runningThreads = 0; 
        statusMessage = "C√°lculo completado. \nPresiona ESPACIO para recalcular.";
        ofLogNotice() << statusMessage << " Tiempo: " << calculationTime << " s";
        texture.loadData(pixels);
    }
}

//--------------------------------------------------------------
void ofApp::draw() {
    ofSetColor(255);
    texture.draw(0, 0, ofGetWidth(), ofGetHeight());

    stringstream ss;
    ss << "Version: Paralelo (ofThread)" << endl;

    ss << "Status: " << statusMessage << endl;
    if (!calculating && calculationTime > 0.0f) {
        ss << "Ultimo Tiempo: " << ofToString(calculationTime, 3) << " s" << endl;
    }
    ss << "Hilos Usados: " << numThreads << endl;
    // ss << "Hilos Corriendo: " << runningThreads << endl; // Podr√≠a fluctuar r√°pido

    ss << "Max Iteraciones: " << maxIterations << endl;
    ss << "Resolucion: " << imgWidth << "x" << imgHeight << endl;
    ss << "FPS: " << ofToString(ofGetFrameRate(), 0);

    ofSetColor(0, 180);
    ofDrawRectangle(10, 10, 350, 120); // Un poco m√°s grande
    ofSetColor(255);
    ofDrawBitmapString(ss.str(), 20, 30);
}

//--------------------------------------------------------------
void ofApp::exit() {
    ofLogNotice() << "Saliendo, esperando a los hilos...";
    for (auto& thread : threads) {
        thread->waitForThread(true); // Espera bloqueante hasta que el hilo termine
        delete thread; // Liberar memoria
    }
    threads.clear();
    ofLogNotice() << "Hilos detenidos y limpiados. Adi√≥s.";
}

//--------------------------------------------------------------
void ofApp::keyPressed(int key) {
    if (key == ' ') {
        maxIterations += 1;
        startCalculation();
    }
	if (key == 'n') {
		maxIterations = 0;
		startCalculation();
	}
}
```

:::note[üßêüß™‚úçÔ∏è Reporta en tu bit√°cora]
- Ejecuta el c√≥digo y observa el resultado. 
- Analiza el c√≥digo y estudia detenidamente su funcionamiento. En la fase de aplicaci√≥n tendr√°s que retomar 
este c√≥digo para resolver un reto.
- Experimenta modificando, PERO, no olvides c√≥mo investigamos en este curso:

    - Realiza cambios peque√±os y espec√≠ficos.
    - Lanza una hip√≥tesis sobre lo que crees que va a pasar.
    - Ejecuta el c√≥digo y observa lo que ocurre.
    - ¬øTu hip√≥tesis era correcta? ¬øPor qu√© crees que ocurre esto?

Te dejo una idea para comenzar a experimentar: ¬øQu√© ocurre si cambias el n√∫mero de hilos? ¬øPor qu√© crees que ocurre esto?
:::

### Actividad 04

#### El Reto del estado compartido

:::note[üéØ Enunciado]
Hemos visto que los hilos pueden mejorar la responsividad y acelerar c√°lculos independientes. Pero, ¬øQu√© pasa cuando m√∫ltiples hilos necesitan trabajar sobre la *misma estructura de datos compleja* al mismo tiempo? Analizaremos el c√≥digo proporcionado para entender por qu√© la sincronizaci√≥n se vuelve esencial. **No necesitas implementar nada aqu√≠, solo analizar.**
:::

**¬øQu√© es el algoritmo de Flocking?**

El algoritmo de Flocking es un modelo de comportamiento colectivo que simula el movimiento de grupos de entidades (como aves o peces) en un entorno. Se basa en tres reglas simples: separaci√≥n, alineaci√≥n y cohesi√≥n. Estas reglas permiten que las entidades se muevan de manera coordinada y eviten colisiones entre s√≠. El algoritmo se utiliza en gr√°ficos por computadora y simulaciones para crear movimientos naturales y realistas de grupos de entidades.

El concepto de las reglas simples de separaci√≥n, alineaci√≥n y cohesi√≥n fue introducido por Craig Reynolds en 1986. En su trabajo, Reynolds demostr√≥ que estas reglas simples pueden dar lugar a comportamientos complejos y realistas en grupos de entidades.
El algoritmo de Flocking se basa en la idea de que cada entidad (o "boid") toma decisiones basadas en su entorno inmediato y en las posiciones y velocidades de sus vecinos. Esto permite que el grupo se mueva de manera cohesiva y evite colisiones, creando un comportamiento emergente.

La separaci√≥n evita que los boids se acerquen demasiado entre s√≠, la alineaci√≥n les permite coincidir con la direcci√≥n de sus vecinos y la cohesi√≥n les anima a moverse hacia el centro del grupo. Estas reglas simples permiten que los boids se comporten de manera natural y realista en un entorno simulado.

La separaci√≥n se implementa calculando la distancia entre un boid y sus vecinos cercanos. Si la distancia es menor que un umbral predefinido, se aplica una fuerza de separaci√≥n para alejar al boid de sus vecinos. La alineaci√≥n se implementa calculando la direcci√≥n promedio de los vecinos cercanos y ajustando la direcci√≥n del boid para que coincida con esa direcci√≥n. La cohesi√≥n se implementa calculando el centro de masa de los vecinos cercanos y aplicando una fuerza hacia ese punto.

Ahora te mostrar√© un ejemplo de c√≥mo implementar el algoritmo de Flocking en openFrameworks. El c√≥digo est√° dividido en dos partes: una implementaci√≥n sin hilos y otra con hilos.

**1. Flocking sin Hilos:**

Usa el evento `mouseDragged` para a√±adir nuevos boids a la simulaci√≥n. Observa qu√© ocurre con el frame rate a medida que a√±ades m√°s boids.

```cpp
// ofApp.h
#pragma once

#include "ofMain.h"

class Boid {
public:
    Boid(float x, float y);
    void run(const vector<Boid>& boids);
    void applyForce(ofVec2f force);
    void flock(const vector<Boid>& boids);
    void update();
    void borders();
    ofVec2f seek(ofVec2f target);
    void draw();

    ofVec2f separate(const vector<Boid>& boids);
    ofVec2f align(const vector<Boid>& boids);
    ofVec2f cohere(const vector<Boid>& boids);

    ofVec2f position;
    ofVec2f velocity;
    ofVec2f acceleration;
    float r;
    float maxforce;
    float maxspeed;
};


class Flock {
public:
    void addBoid(float x, float y);
    void run();

    vector<Boid> boids;
};


class ofApp : public ofBaseApp {

public:
    void setup();
    void update();
    void draw();
    void mouseDragged(int x, int y, int button);

    Flock flock;
};
```

```cpp
// ofApp.cpp
#include "ofApp.h"

Boid::Boid(float x, float y) {
    acceleration.set(0, 0);
    velocity.set(ofRandom(-1, 1), ofRandom(-1, 1));
    position.set(x, y);
    r = 3.0;
    maxspeed = 3;
    maxforce = 0.05;
}

void Boid::run(const vector<Boid>& boids) {
    flock(boids);
    update();
    borders();
}

void Boid::applyForce(ofVec2f force) {
    acceleration += force;
}

void Boid::flock(const vector<Boid>& boids) {
    ofVec2f sep = separate(boids);
    ofVec2f ali = align(boids);
    ofVec2f coh = cohere(boids);
    sep *= 1.5;
    ali *= 1.0;
    coh *= 1.0;

    applyForce(sep);
    applyForce(ali);
    applyForce(coh);
}

void Boid::update() {
    velocity += acceleration;
    velocity.limit(maxspeed);
    position += velocity;
    acceleration *= 0;
}

ofVec2f Boid::seek(ofVec2f target) {
    ofVec2f desired = target - position;
    desired.normalize();
    desired *= maxspeed;
    ofVec2f steer = desired - velocity;
    steer.limit(maxforce);
    return steer;
}

void Boid::borders() {

    float width = ofGetWidth();
    float height = ofGetHeight();

    if (position.x < -r) position.x = width + r;
    if (position.y < -r) position.y = height + r;
    if (position.x > width + r) position.x = -r;
    if (position.y > height + r) position.y = -r;

}

void Boid::draw() {
    float theta = atan2(velocity.y, velocity.x) + PI / 2;
    ofSetColor(255);
    ofFill();
    ofPushMatrix();
    ofTranslate(position.x, position.y);
    ofRotate(ofRadToDeg(theta));
    ofBeginShape();
    ofVertex(0, -r * 2);
    ofVertex(-r, r * 2);
    ofVertex(r, r * 2);
    ofEndShape();
    ofPopMatrix();
}

ofVec2f Boid::separate(const vector<Boid>& boids) {
    float desiredSeparation = 25;
    ofVec2f steer(0, 0);
    int count = 0;

    for (const Boid& other : boids) {
        float d = position.distance(other.position);
        if (d > 0 && d < desiredSeparation) {
            ofVec2f diff = position - other.position;
            diff.normalize();
            diff /= d;
            steer += diff;
            count++;
        }
    }
    if (count > 0) {
        steer /= (float)count;
    }

    if (steer.length() > 0) {
        steer.normalize();
        steer *= maxspeed;
        steer -= velocity;
        steer.limit(maxforce);
    }
    return steer;
}

ofVec2f Boid::align(const vector<Boid>& boids) {
    float neighborDist = 50;
    ofVec2f sum(0, 0);
    int count = 0;

    for (const Boid& other : boids) {
        float d = position.distance(other.position);
        if (d > 0 && d < neighborDist) {
            sum += other.velocity;
            count++;
        }
    }
    if (count > 0) {
        sum /= (float)count;
        sum.normalize();
        sum *= maxspeed;
        ofVec2f steer = sum - velocity;
        steer.limit(maxforce);
        return steer;
    }
    return ofVec2f(0, 0);
}

ofVec2f Boid::cohere(const vector<Boid>& boids) {
    float neighborDist = 50;
    ofVec2f sum(0, 0);
    int count = 0;

    for (const Boid& other : boids) {
        float d = position.distance(other.position);
        if (d > 0 && d < neighborDist) {
            sum += other.position;
            count++;
        }
    }
    if (count > 0) {
        sum /= count;
        return seek(sum);
    }
    return ofVec2f(0, 0);
}

void Flock::addBoid(float x, float y) {
    boids.emplace_back(x, y);
}

void Flock::run() {
    for (Boid& b : boids) {
        b.run(boids);
    }
}


void ofApp::setup() {
    flock.boids.reserve(120);
    for (int i = 0; i < 120; i++) {
        flock.addBoid(ofGetWidth() / 2, ofGetHeight() / 2);
    }
}

void ofApp::update() {
    flock.run();
}

void ofApp::draw() {
    ofBackground(0);
    for (Boid& b : flock.boids) {
        b.draw();
    }
    ofDrawBitmapStringHighlight("FPS: " + ofToString(ofGetFrameRate()), 20, 20);
    ofDrawBitmapStringHighlight("Boids: " + ofToString(flock.boids.size()), 20, 40);

}

void ofApp::mouseDragged(int x, int y, int button) {
    flock.addBoid(x, y);
}
```

**2. Flocking con Hilos:**

```cpp
// ofApp.h
#pragma once

#include "ofMain.h"
#include "ofThread.h"

class Boid {
public:
    Boid(float x, float y);
    void run(const vector<Boid>& boids);
    void applyForce(ofVec2f force);
    void flock(const vector<Boid>& boids);
    void update();
    void borders();
    ofVec2f seek(ofVec2f target);
    void draw();

    ofVec2f separate(const vector<Boid>& boids);
    ofVec2f align(const vector<Boid>& boids);
    ofVec2f cohere(const vector<Boid>& boids);

    ofVec2f position;
    ofVec2f velocity;
    ofVec2f acceleration;
    float r;
    float maxforce;
    float maxspeed;
};


class Flock : public ofThread {
public:
    void addBoid(int x, int y);
    void run();
    void threadedFunction();

    std::vector<Boid> boids;
};


class ofApp : public ofBaseApp {

public:
    void setup();
    void update();
    void draw();
    void exit();
    void mouseDragged(int x, int y, int button);

    Flock flock;
};
```

```cpp
// ofApp.cpp
#include "ofApp.h"

Boid::Boid(float x, float y) {
    acceleration.set(0, 0);
    velocity.set(ofRandom(-1, 1), ofRandom(-1, 1));
    position.set(x, y);
    r = 3.0;
    maxspeed = 3;
    maxforce = 0.05;
}

void Boid::run(const vector<Boid>& boids) {
    flock(boids);
    update();
    borders();
}

void Boid::applyForce(ofVec2f force) {
    acceleration += force;
}

void Boid::flock(const vector<Boid>& boids) {
    ofVec2f sep = separate(boids);
    ofVec2f ali = align(boids);
    ofVec2f coh = cohere(boids);
    sep *= 1.5;
    ali *= 1.0;
    coh *= 1.0;

    applyForce(sep);
    applyForce(ali);
    applyForce(coh);
}

void Boid::update() {
    velocity += acceleration;
    velocity.limit(maxspeed);
    position += velocity;
    acceleration *= 0;
}

ofVec2f Boid::seek(ofVec2f target) {
    ofVec2f desired = target - position;
    desired.normalize();
    desired *= maxspeed;
    ofVec2f steer = desired - velocity;
    steer.limit(maxforce);
    return steer;
}

void Boid::borders() {
    if (position.x < -r) position.x = ofGetWidth() + r;
    if (position.y < -r) position.y = ofGetHeight() + r;
    if (position.x > ofGetWidth() + r) position.x = -r;
    if (position.y > ofGetHeight() + r) position.y = -r;
}

void Boid::draw() {
    float theta = atan2(velocity.y, velocity.x) + PI / 2;
    ofSetColor(255);
    ofFill();
    ofPushMatrix();
    ofTranslate(position.x, position.y);
    ofRotate(ofRadToDeg(theta));
    ofBeginShape();
    ofVertex(0, -r * 2);
    ofVertex(-r, r * 2);
    ofVertex(r, r * 2);
    ofEndShape();
    ofPopMatrix();
}

ofVec2f Boid::separate(const vector<Boid>& boids) {
    float desiredSeparation = 25;
    ofVec2f steer(0, 0);
    int count = 0;

    for (const Boid& other : boids) {
        float d = position.distance(other.position);
        if (d > 0 && d < desiredSeparation) {
            ofVec2f diff = position - other.position;
            diff.normalize();
            diff /= d;
            steer += diff;
            count++;
        }
    }
    if (count > 0) {
        steer /= (float)count;
    }

    if (steer.length() > 0) {
        steer.normalize();
        steer *= maxspeed;
        steer -= velocity;
        steer.limit(maxforce);
    }
    return steer;
}

ofVec2f Boid::align(const vector<Boid>& boids) {
    float neighborDist = 50;
    ofVec2f sum(0, 0);
    int count = 0;

    for (const Boid& other : boids) {
        float d = position.distance(other.position);
        if (d > 0 && d < neighborDist) {
            sum += other.velocity;
            count++;
        }
    }
    if (count > 0) {
        sum /= (float)count;
        sum.normalize();
        sum *= maxspeed;
        ofVec2f steer = sum - velocity;
        steer.limit(maxforce);
        return steer;
    }
    return ofVec2f(0, 0);
}

ofVec2f Boid::cohere(const vector<Boid>& boids) {
    float neighborDist = 50;
    ofVec2f sum(0, 0);
    int count = 0;

    for (const Boid& other : boids) {
        float d = position.distance(other.position);
        if (d > 0 && d < neighborDist) {
            sum += other.position;
            count++;
        }
    }
    if (count > 0) {
        sum /= count;
        return seek(sum);
    }
    return ofVec2f(0, 0);
}

void Flock::addBoid(int x, int y) {
    lock();
    boids.emplace_back(x, y);
    unlock();
}

void Flock::run() {
    if (!isThreadRunning()) {
        startThread();
    }
}

void Flock::threadedFunction() {
    while (isThreadRunning()) {
        lock();
        for (Boid& b : boids) {
            b.run(boids);
        }
        unlock();
        sleep(5);
    }
}

void ofApp::setup() {
    // Add an initial set of boids
    for (int i = 0; i < 120; i++) {
        flock.addBoid(ofGetWidth() / 2, ofGetHeight() / 2);
    }
}

void ofApp::update() {
    flock.run();
}

void ofApp::draw() {
    ofBackground(0);

    flock.lock();
    for (Boid& b : flock.boids) {
        b.draw();
    }
    flock.unlock();

    ofDrawBitmapStringHighlight("FPS: " + ofToString(ofGetFrameRate()), 20, 20);
    ofDrawBitmapStringHighlight("Boids: " + ofToString(flock.boids.size()), 20, 40);
}

void ofApp::mouseDragged(int x, int y, int button) {
    flock.addBoid(x, y);
}

void ofApp::exit() {
    flock.stopThread();
    flock.waitForThread();
}
```

Analicemos juntos varias partes del c√≥digo:

- **Flocking sin hilos**: en este enfoque, la simulaci√≥n de los boids se realiza en el hilo principal. Cada boid actualiza su posici√≥n y dibuja su representaci√≥n gr√°fica en cada frame. Esto puede llevar a una disminuci√≥n del rendimiento a medida que se a√±aden m√°s boids, ya que todo el trabajo se realiza en un solo hilo.
- **Flocking con hilos**: en este enfoque, la simulaci√≥n de los boids se realiza en un hilo separado. Esto permite que el hilo principal se encargue de la representaci√≥n gr√°fica, mientras que el hilo de la simulaci√≥n se encarga de actualizar las posiciones de los boids. La sincronizaci√≥n se maneja mediante `lock()` y `unlock()` para evitar condiciones de carrera al acceder a la lista de boids.

:::note[üßê‚úçÔ∏è Reporta en tu bit√°cora]
Observa ambos c√≥digos y responde a las siguientes preguntas:

1. ¬øCu√°l es la estructura de datos principal que contiene la informaci√≥n de todos los boids y que es accedida por m√∫ltiples hilos (el hilo principal para dibujar, el hilo trabajador para actualizar)?
2. Observa la funci√≥n `Flock::threadedFunction()` donde el hilo trabajador calcula el movimiento. ¬øQu√© operaciones realizan sobre el vector de boids compartido? 
*   Observa la funci√≥n `ofApp::draw()`. ¬øQu√© operaci√≥n realiza sobre el vector compartido?
*   Observa `Flock::addBoid()` y `ofApp::mouseDragged()`. ¬øQu√© operaci√≥n realizan?

3. Describe un escenario *espec√≠fico* y *concreto* donde la falta de sincronizaci√≥n podr√≠a causar un problema. Por ejemplo:

    *   "El Hilo X est√° recorriendo el vector para calcular la separaci√≥n (leyendo posiciones). Al mismo tiempo, el Hilo Y (llamado desde `mouseDragged`) intenta a√±adir un nuevo boid al final del vector. ¬øQu√© podr√≠a pasarle al iterador del Hilo X o al tama√±o del vector que est√° usando?"

4. Localiza todas las llamadas a `lock()` y `unlock()` dentro de la clase `Flock` (o donde se acceda al vector compartido).

**Justificaci√≥n:** para uno de los escenarios problem√°ticos que describiste arriba, explica c√≥mo las llamadas a `lock()`/`unlock()` en las secciones de c√≥digo relevantes *evitan* que ocurra ese problema espec√≠fico.

5. Aunque los locks aseguran la correctitud, ¬øPuedes intuir por qu√© tener muchos hilos esperando para adquirir un lock sobre el mismo vector (alta **contenci√≥n**) podr√≠a limitar el beneficio de rendimiento del paralelismo en este caso? Justifica tu respuesta.
:::

En el ejemplo que te di del flocking con hilos, el hilo principal se encarga de dibujar los boids y el hilo secundario se encarga de calcular el movimiento de los boids. Sin embargo, este escenario es muy limitado porque solo hay dos hilos: el principal y el hilo trabajador que calcula el flocking, pero **realmente no se est√° explotando la idea de tener hilos**. **¬øEs correcto esto?**

:::note[üßê‚úçÔ∏è Reporta en tu bit√°cora]
Este es un ejercicio mental y de reflexi√≥n, no tienes que implementar nada, solo pensar:

Piensa en la pregunta que te acabo de hacer. ¬øQu√© pasar√≠a si tuvi√©ramos varios hilos que calculan el movimiento de los boids? ¬øC√≥mo podr√≠as implementar esto? ¬øQu√© problemas crees que podr√≠an surgir? ¬øC√≥mo podr√≠as solucionarlos? 
:::

:::note[üßêüß™‚úçÔ∏è Reporta en tu bit√°cora]
- Analiza el c√≥digo del Flocking sin hilos y el Flocking con hilos. ¬øQu√© diferencias encuentras? ¬øPor qu√© crees que es importante la sincronizaci√≥n en el segundo caso?
- ¬øPor qu√© al a√±adir un nuevo boid la simulaci√≥n se ralentiza? ¬øQu√© ocurre si a√±ades muchos boids?
- Notaste que la versi√≥n con hilos tiene un `sleep(5)` en el hilo trabajador. ¬øPor qu√© crees que se ha a√±adido? ¬øQu√© pasar√≠a si lo eliminamos?
- Compara el rendimiento de ambos enfoques. ¬øCu√°l crees que es m√°s eficiente? ¬øPor qu√©?
- El uso de lock y unlock en la versi√≥n con hilos es crucial para evitar condiciones de carrera. ¬øQu√© pasar√≠a si no se usaran? ¬øC√≥mo afectar√≠a esto al comportamiento del programa? (No olvides por favor que las condiciones de carrera son dif√≠ciles de reproducir, as√≠ que no te preocupes si no puedes verlas en acci√≥n).
:::

**Reflexi√≥n final:**

El ejemplo de flocking con hilos, aunque utiliza ofThread, no explota realmente el paralelismo para acelerar el c√°lculo del flocking en s√≠ mismo.

Lo que hace esa implementaci√≥n es:

- Mover el trabajo pesado: traslada el bucle principal que calcula boid.run() para todos los boids desde el hilo principal (ofApp::update) a un √∫nico hilo secundario (Flock::threadedFunction).  
- Lograr responsividad: el principal beneficio aqu√≠ es que el hilo principal (que maneja el dibujo y los eventos de UI como mouseDragged) ya no se bloquea mientras se realizan los c√°lculos potencialmente largos del flocking. La aplicaci√≥n se siente m√°s fluida y responde a la interacci√≥n incluso si el c√°lculo del flocking es intensivo. 
- C√°lculo secuencial (dentro del hilo): dentro de Flock::threadedFunction, el bucle for (Boid& b : boids) sigue procesando cada boid uno tras otro, de forma secuencial. No hay m√∫ltiples hilos trabajando simult√°neamente en diferentes subconjuntos de boids para calcular sus interacciones.

:::note[üßê‚úçÔ∏è Reporta en tu bit√°cora]
¬øQu√© ocurre si mientras el hilo trabajador est√° calculando el movimiento de los boids, el hilo principal intenta a√±adir un nuevo boid? ¬øSe congelar√° la aplicaci√≥n? ¬øPor qu√©?
:::

En resumen, la versi√≥n de flocking con hilos mejora la responsividad al mover el trabajo pesado a un hilo secundario, pero no logra paralelismo real para acelerar el c√°lculo del flocking. La implementaci√≥n actual sigue siendo secuencial dentro del hilo secundario.

Para explotar verdaderamente el paralelismo en el flocking, necesitar√≠as m√∫ltiples hilos trabajadores. La idea ser√≠a crear varios hilos (no solo uno). Luego dividir el conjunto de boids o las tareas de c√°lculo entre esos hilos. Por ejemplo: cada hilo calcula las interacciones para un subconjunto de boids o usar un enfoque basado en tareas donde cada hilo toma un boid, calcula sus fuerzas y actualiza su estado. Sin embargo, el gran desaf√≠o aqu√≠ es que para calcular las fuerzas de flocking (separaci√≥n, alineaci√≥n, cohesi√≥n), un boid necesita informaci√≥n sobre sus vecinos. Si diferentes hilos trabajan en diferentes boids, necesitar√°n leer de forma segura la informaci√≥n (posiciones, velocidades) de boids que podr√≠an estar siendo modificados por otros hilos. Esto requiere una sincronizaci√≥n mucho m√°s cuidadosa y granular que simplemente bloquear todo el vector, o t√©cnicas m√°s avanzadas (como dividir el espacio, usar copias de datos, etc.), lo cual complica significativamente el c√≥digo y puede introducir sus propios cuellos de botella por la sincronizaci√≥n.

**Conclusi√≥n** 

El ejemplo es bueno para ilustrar c√≥mo mover una tarea completa a un hilo secundario para mejorar la responsividad, y tambi√©n introduce la necesidad de lock/unlock al acceder a datos compartidos (el vector boids) desde diferentes hilos (el hilo principal para draw/addBoid y el hilo secundario para threadedFunction). Sin embargo, no es un ejemplo de paralelizaci√≥n del c√°lculo para obtener **speedup**. 


## Apply: Aplicaci√≥n üõ†

### Actividad 05

#### Aplicaci√≥n: Julia set interactivo

:::note[üéØ Enunciado]
Es hora de aplicar lo aprendido sobre paralelismo. Tomar√°s el c√≥digo funcional del fractal de Mandelbrot que estudiante (¬øCierto?) y lo modificar√°s para calcular y visualizar el **conjunto de Julia**. Har√°s que la constante `k` que define el fractal de Julia dependa de la posici√≥n del mouse, creando un explorador interactivo. El c√°lculo seguir√° siendo paralelo.
:::

![Julia set](../../../assets/JuliaSet.png)

1. Crea un nuevo proyecto de openFrameworks y copia el c√≥digo de Mandelbrot en su versi√≥n paralela.  
2. Modifica la l√≥gica de c√°lculo:

* Localiza la funci√≥n que calcula el valor de un p√≠xel (ej. `calculateMandelbrotPixel`). Necesitas cambiar su l√≥gica para calcular Julia en lugar de Mandelbrot. ¬øCu√°l es la diferencia?
    * **Mandelbrot:** `z = z^2 + c` (donde `c` es la coordenada del p√≠xel, `z` empieza en 0).
    * **Julia:** `z = z^2 + k` (donde `k` es una constante fija para toda la imagen, `z` empieza en la coordenada del p√≠xel).
* Necesitar√°s:
    * Una variable (probablemente global o en `ofApp` si refactorizas) para almacenar la constante compleja `k` actual (ej. `glm::vec2 juliaK;`).
    * Modificar la funci√≥n de c√°lculo para que:
        * Reciba `k` como par√°metro (o la acceda globalmente).
        * Inicialice `z` con las coordenadas complejas correspondientes al p√≠xel `(x, y)`.
        * Itere usando `z = z * z + k;` (la multiplicaci√≥n `z*z` requiere manejar n√∫meros complejos o sus componentes).
        * El resto (comprobaci√≥n de escape, conteo de iteraciones) es similar a Mandelbrot.

3. Integra la interacci√≥n del mouse:

* Necesitas actualizar la constante `juliaK` bas√°ndose en la posici√≥n del mouse.
* En la funci√≥n `update()` o en un callback de movimiento del mouse (`mouseMoved`), mapea `mouseX` y `mouseY` a un rango adecuado para las partes real e imaginaria de `k`. Un rango com√∫n es de -1.5 a 1.5 para ambos.

    ```cpp
    // Ejemplo de mapeo dentro de update() o mouseMoved()
    // Asumiendo que tienes windowWidth y windowHeight
    juliaK.x = ofMap(mouseX, 0, windowWidth, -1.5f, 1.5f);
    juliaK.y = ofMap(mouseY, 0, windowHeight, -1.5f, 1.5f);
    // Necesitar√°s una bandera o mecanismo para indicar que hay que recalcular
    // si k ha cambiado.
    ```

*   **Importante:** cada vez que `juliaK` cambie, necesitar√°s disparar un rec√°lculo *completo* de la imagen usando los hilos. La estructura de hilos que divide el trabajo por filas puede reutilizarse tal cual, solo necesitas asegurarte de que la funci√≥n que llaman ahora calcula Julia con la `k` actualizada.

4. Reutilizar la estructura de hilos: la l√≥gica para crear, lanzar, y esperar a los hilos que ten√≠as en el Mandelbrot paralelo deber√≠a poder reutilizarse casi directamente. Cada hilo seguir√° calculando un conjunto de filas, pero ahora llamar√° a tu nueva funci√≥n `calculateJuliaPixel` (o como la llames) pas√°ndole la `k` actual.

:::note[üßêüß™‚úçÔ∏è Reporta en tu bit√°cora]
1.  Pega la parte clave de tu funci√≥n modificada que calcula el p√≠xel para el conjunto de Julia. Recuerda utilizar un bloque cpp.  
2.  Muestra c√≥mo mapeaste la posici√≥n del mouse a la constante `k`.  
3.  Describe brevemente c√≥mo reutilizaste la estructura de hilos de la versi√≥n Mandelbrot. ¬øTuviste que cambiar mucho esa parte?  
4.  ¬øC√≥mo te aseguraste de que la imagen se recalculara cuando el mouse se mov√≠a?  
5.  Incluye al menos dos capturas de pantalla que muestren diferentes fractales de Julia generados al mover el mouse en tu aplicaci√≥n.  
6.  ¬øEncontraste alg√∫n desaf√≠o particular al implementar la interacci√≥n o modificar el c√°lculo?  
:::

## Evidencias üóÇÔ∏è

<Aside type="note" title="RUBRICA!">
* Recuerda que la bit√°cora se cierra el 30 de octubre de 2025 a las 7:49 a.m. No olvides que el aprendizaje es un proceso que se 
plasma en la bit√°cora. La bit√°cora no es un resultado que se llena a √∫ltima hora.
* Si no realizas la autoevaluaci√≥n tu nota ser√° 0.
* Si una actividad no est√° COMPLETA debes multiplicar la nota de esa actividad por el porcentaje de avance que tengas.
* Si usas IA para generar c√≥digo, texto o im√°genes la nota en esa actividad ser√° 0.

**R√∫brica de evaluaci√≥n del proceso**

5: realic√© las 5 actividades completas y la autoevaluaci√≥n.  
4: realic√© 4 actividades completas y la autoevaluaci√≥n.  
3: realic√© 3 actividades completas y la autoevaluaci√≥n.  
2: realic√© 2 actividades completas y la autoevaluaci√≥n.  
1: realic√© 1 actividad completa y la autoevaluaci√≥n.  
0: no realic√© ninguna actividad o no realic√© la autoevaluaci√≥n.  
</Aside>

<Aside type="danger" title="EVIDENCIAS EN BIT√ÅCORA">

1. Realiza las actividades propuestas en esta unidad y documenta todo el proceso en tu bit√°cora.
2. Realiza la autoevaluaci√≥n indicando:
    * Tu nota propuesta.
    * La defensa de esa nota para cada actividad. 
</Aside>


## Reflect: Consolidaci√≥n y metacognici√≥n ü§î

1. En una hoja de papel o un white board digital te pedir√© que hagas un inventario de los 
conceptos de esta unidad. Luego construye un diagrama donde ubiques todos los conceptos, tratando 
de agruparlos y relacionarlos entre s√≠. 
2. Preg√∫ntate: ¬øQu√© conceptos domino bien? ¬øCu√°les me cuestan m√°s trabajo?
3. Preg√∫ntate para qu√© pueden servirte estos conceptos.
4. ¬øQu√© hiciste bien en esta unidad que debes continuar haciendo?
5. ¬øQu√© deber√≠as comenzar a hacer para mejorar tu proceso?
6. Formula tu plan de acci√≥n personal para abordar aquello que te cueste m√°s trabajo.
